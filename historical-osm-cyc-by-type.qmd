---
title: "Untitled"
format: html
editor: visual
---

---
title: "Getting historical OSM infrastruture data"
format: gfm
editor: visual
---

## Intro

This repository aims to showercase how to download OSM cycling data distinguishing by type of infrastructure based on their level of segregation data using R. 

We use two different workflow approaches: (1) creating a filter from scratch using `osmextract`, slower but control of the details of the filter, and (2) using `osmactive`, faster but trusting the packages filter.

As example, we obtain and plot the cycling networks by type for the cities of Barcelona, Montréal, Milan, and Paris.

```{r include=FALSE}
#| label: Common inputs
#remotes::install_github("ropensci/osmextract")
library(osmdata)
library(osmextract)
library(osmdata)
library(sf)
library(tidyverse)
library(tmap)
library(grid)
library(gridExtra)
library(spdep)
```

## “From scratch” (osmextract) workflow

```{r boundaries}
#| include: false
# Get the boundary data for each city at the city, neighbourhood and census section levels  

# Define the cities with their English names
cities <- list(
  "Barcelona" = "Barcelona, Spain",
  "Montréal" = "Montréal, Canada",
  "Milan" = "Milano, Italy",
  "Paris" = "Paris, France"
)

# Create the data directory if it doesn't exist
if (!dir.exists("data/")) {
  dir.create("data/")
}

for (english_name in names(cities)) {
  city <- cities[[english_name]]
  try({
    # Get the bounding box
    bbox <- getbb(city, format_out = "polygon")
    if (is.null(bbox)) {
      warning(paste("Bounding box for", city, "not found"))
      next
    }
    
    # Query for the city's boundary with admin_level 8
    city_boundary <- opq(bbox = bbox) |>
      add_osm_feature(key = "boundary", value = "administrative") |>
      add_osm_feature(key = "name", value = gsub(",.*", "", city), value_exact = FALSE) |>
      add_osm_feature(key = "admin_level", value = "8") |>
      osmdata_sf()
    
    if (is.null(city_boundary$osm_multipolygons)) {
      warning(paste("Boundary for", city, "not found. Query returned no results."))
      next
    }
    
    city_perimeter <- city_boundary$osm_multipolygons
    
    # Ensure only one observation
    city_perimeter <- city_perimeter[1, ]
    
    # Convert to MULTIPOLYGON if necessary
    city_perimeter <- st_cast(city_perimeter, "MULTIPOLYGON")
    
    # Check and fix invalid geometries
    if (!all(st_is_valid(city_perimeter))) {
      city_perimeter <- st_make_valid(city_perimeter)
    }
    
    # Create city-specific directory if it doesn't exist
    city_dir <- paste0("data/", tolower(english_name))
    if (!dir.exists(city_dir)) {
      dir.create(city_dir)
    }
    
    # Write to GeoPackage (overwrite if exists) using the English name
    st_write(city_perimeter, paste0(city_dir, "/", tolower(english_name), "_perimeter.gpkg"), layer = english_name, driver = "GPKG", append = FALSE)
    
    message(paste("Successfully wrote perimeter for", english_name))
  }, silent = FALSE)
}
```

```{r infras}
#| include: false
# Get the OSM infrastructture data
# Define vectortranslate options
my_vectortranslate <- c(
  "-select", "osm_id,highway", 
  "-where", "highway IN ('living_street', 'pedestrian', 'cycleway', 'motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'unclassified', 'residential', 'motorway_link', 'trunk_link', 'primary_link', 'secondary_link', 'tertiary_link', 'service', 'track', 'bus_guideway', 'escape', 'raceway', 'busway')"
)

# Define a list of cities with their corresponding region and subregion
cities <- list(
  "Barcelona" = c("Barcelona", "Cataluña", "Spain"),
  "Montréal"  = c("Montréal", "Québec",   "Canada"),
  "Milan"     = c("Milan",    "Nord-Ovest","Milan"),
  "Paris"     = c("Paris",    "Ile-de-France", "Paris")
)

for (english_name in names(cities)) {
  city_info <- cities[[english_name]]
  city      <- city_info[1]
  region    <- city_info[2]
  subregion <- city_info[3]
  
  try({
    # Define file path for the perimeter
    perimeter_path <- paste0("data/", tolower(english_name), "/", tolower(english_name), "_perimeter.gpkg")
    
    # Read the perimeter from GeoPackage
    if (file.exists(perimeter_path)) {
      city_perimeter <- st_read(perimeter_path, layer = tolower(english_name))
      # Ensure CRS is WGS84
      if (st_crs(city_perimeter) != 4326) {
        message(paste("Transforming CRS for", english_name, "to WGS 84"))
        city_perimeter <- st_transform(city_perimeter, 4326)
      }
    } else {
      warning(paste("Perimeter file for", english_name, "not found"))
      next
    }
    
    # Create city-specific directory if it doesn't exist
    city_dir <- paste0("data/", tolower(english_name))
    if (!dir.exists(city_dir)) dir.create(city_dir, recursive = TRUE)

    # Helper: fetch + crop; SKIPS if output already exists
    fetch_and_crop_data <- function(area, version, perimeter, output_file) {
      if (file.exists(output_file)) {
        message("↪ Skipping (exists): ", basename(output_file))
        return(invisible(NULL))
      }

      # SPECIAL CASE: Barcelona 2017 -> use 'spain' and avoid vectortranslate filter
      force_spain_2017 <- (english_name == "Barcelona" && version == "170101")

      lines_data <- tryCatch({
        if (force_spain_2017) {
          # Fast pre-clip by bbox; read lines with highway tag present
          oe_get("spain",
                 version = version,
                 boundary = st_bbox(perimeter), boundary_type = "clipsrc",
                 layer = "lines", extra_tags = "highway",
                 quiet = FALSE)
        } else {
          # Your original call (keep vectortranslate filter)
          oe_get(area,
                 version = version,
                 vectortranslate_options = my_vectortranslate,
                 quiet = FALSE)
        }
      }, error = function(e) {
        message(paste("Error fetching", version, "lines for", english_name, ":", e$message))
        return(NULL)
      })
      
      if (!is.null(lines_data) && nrow(lines_data) > 0) {
        # Keep only (multi)lines and clip to polygon
        lines_data <- lines_data[
          sf::st_geometry_type(lines_data$geometry) %in% c("LINESTRING","MULTILINESTRING"), ]
        if (nrow(lines_data) == 0) {
          message(paste("No LINESTRINGs for", english_name, "(", version, ")"))
          return(invisible(NULL))
        }

        # Final clip to the city polygon
        lines_data <- sf::st_intersection(lines_data, perimeter)

        if (nrow(lines_data) > 0) {
          sf::st_write(lines_data, output_file,
                       layer = gsub("\\.gpkg$", "", basename(output_file)),
                       driver = "GPKG", append = FALSE)
          message(paste("✓ Saved", basename(output_file), "(", nrow(lines_data), "features )"))
        } else {
          message(paste("No lines remaining after clipping for", english_name, "(", version, ")"))
        }
      } else {
        message(paste("No data found for", english_name, "(", version, ")"))
      }
    }

    # Fetch and crop 170101 (2017) — Barcelona uses 'spain' internally
    fetch_and_crop_data(region,   "170101", city_perimeter,
                        paste0(city_dir, "/", tolower(english_name), "_170101_lines.gpkg"))

    # Fetch and crop 240101 (2024)
    fetch_and_crop_data(subregion,"240101", city_perimeter,
                        paste0(city_dir, "/", tolower(english_name), "_240101_lines.gpkg"))

    message(paste("Done:", english_name))
  }, silent = FALSE)
}
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| paged-print: false
# --- cities to plot (match your folder names under data/) ---
city_tags <- c("barcelona", "montréal", "milan", "paris")  # add/remove as needed
versions  <- c("170101","240101")  # 2017 & 2024

# --- palette & helpers ---
pal <- c("cycleway"="#E41A1C","pedestrian"="#377EB8","living street"="#4DAF4A","others"="grey")

read_perimeter <- function(tag){
  perim_path <- file.path("data", tag, paste0(tag, "_perimeter.gpkg"))
  if (!file.exists(perim_path)) return(NULL)
  # read (single-layer gpkg) and ensure WGS84
  st_read(perim_path, quiet = TRUE) |> st_transform(4326)
}

read_infra <- function(tag, ver){
  gpkg <- file.path("data", tag, paste0(tag, "_", ver, "_lines.gpkg"))
  lyr  <- paste0(tag, "_", ver, "_lines")
  if (!file.exists(gpkg)) return(NULL)
  x <- tryCatch(st_read(gpkg, layer = lyr, quiet = TRUE), error = function(e) NULL)
  x
}

mk_aggr <- function(x, perimeter){
  if (is.null(x) || nrow(x) == 0) return(NULL)
  x <- st_transform(x, st_crs(perimeter))
  if (!"highway_aggr" %in% names(x)) {
    x <- x |>
      mutate(highway_aggr = dplyr::case_when(
        highway == "cycleway"      ~ "cycleway",
        highway == "pedestrian"    ~ "pedestrian",
        highway == "living_street" ~ "living street",
        TRUE ~ "others"
      ))
  }
  x
}

mk_map <- function(perimeter, x, title){
  if (is.null(x) || nrow(x) == 0) {
    return(tm_shape(perimeter) + tm_borders() + tm_title(paste0(title, " (no data)")))
  }
  tm_shape(perimeter) + tm_borders() +
    tm_shape(x) +
    tm_lines(col = "highway_aggr", lwd = 0.5, col_alpha = 0.6,
             col.scale = tm_scale(values = pal)) +
    tm_title(title)
}

make_city_panel <- function(city_tag){
  perim <- read_perimeter(city_tag)
  if (is.null(perim)) return(NULL)

  x17 <- mk_aggr(read_infra(city_tag, "170101"), perim)
  x24 <- mk_aggr(read_infra(city_tag, "240101"), perim)

  m17 <- mk_map(perim, x17, "2016")
  m24 <- mk_map(perim, x24, "2023")
  tmap_arrange(m17, m24, nrow = 1)
}

# --- OPTION A: display all city panels in the notebook ---
tmap_mode("plot")
panels <- lapply(city_tags, make_city_panel)
# print each panel (skip NULLs)
invisible(lapply(panels[!sapply(panels, is.null)], print))
```

```{r}
city_tags <- c("barcelona", "montréal", "milan", "paris")  # add/remove as needed
versions  <- c("170101","240101")  # 2017 & 2024

# --- palette & helpers ---

pal <- c(
  "off_road"      = "#1b9e77",  # cycleway/path/track not on the carriageway
  "protected_track" = "#d95f02",  # cycleway=track
  "painted_lane"  = "#7570b3",  # cycleway=lane / opposite_lane
  "shared_bus_or_lane" = "#e7298a",  # share_busway, shared_lane, etc.
  "other_cycle"   = "grey80"
)


read_perimeter <- function(tag){
  perim_path <- file.path("data", tag, paste0(tag, "_perimeter.gpkg"))
  if (!file.exists(perim_path)) return(NULL)
  # read (single-layer gpkg) and ensure WGS84
  sf::st_read(perim_path, quiet = TRUE) |>
    sf::st_transform(4326)
}

read_infra <- function(tag, ver){
  gpkg <- file.path("data", tag, paste0(tag, "_", ver, "_lines.gpkg"))
  lyr  <- paste0(tag, "_", ver, "_lines")
  if (!file.exists(gpkg)) return(NULL)
  x <- tryCatch(sf::st_read(gpkg, layer = lyr, quiet = TRUE),
                error = function(e) NULL)
  x
}

# simple, tag-based classification of infrastructure type
mk_aggr <- function(x, perimeter){
  if (is.null(x) || nrow(x) == 0) return(NULL)

  x <- sf::st_transform(x, sf::st_crs(perimeter))

  # ensure these columns exist; if not, create them as NA
  needed_cols <- c("highway", "cycleway", "bicycle")
  for (col in needed_cols) {
    if (!col %in% names(x)) {
      x[[col]] <- NA_character_
    }
  }

  # keep only edges that have *some* cycling relevance
  x <- dplyr::filter(
    x,
    highway %in% c("cycleway", "path", "track") |
      !is.na(cycleway) |
      bicycle %in% c("yes", "designated", "permissive")
  )

  # IMPORTANT: order of conditions – most specific first
  x <- dplyr::mutate(
    x,
    infra_simple = dplyr::case_when(
      # protected tracks along roads
      cycleway %in% c("track") ~ "protected_track",

      # painted lanes
      cycleway %in% c("lane", "opposite_lane") ~ "painted_lane",

      # shared bus / shared lanes
      cycleway %in% c("share_busway", "shared_lane", "shared") ~ "shared_bus_or_lane",

      # fully off-road: mapped as its own facility
      highway %in% c("cycleway", "path", "track") ~ "off_road",

      # everything else that is still cycling-related
      TRUE ~ "other_cycle"
    )
  )

  x
}




mk_map <- function(perimeter, x, title){
  if (is.null(x) || nrow(x) == 0) {
    return(
      tmap::tm_shape(perimeter) +
        tmap::tm_borders() +
        tmap::tm_title(paste0(title, " (no data)"))
    )
  }

  tmap::tm_shape(perimeter) + tmap::tm_borders() +
    tmap::tm_shape(x) +
    tmap::tm_lines(
      col       = "infra_simple",
      lwd       = 0.5,
      col_alpha = 0.7,
      col.scale = tmap::tm_scale(values = pal, na.value = "grey90")
    ) +
    tmap::tm_title(title)
}


make_city_panel <- function(city_tag){
  perim <- read_perimeter(city_tag)
  if (is.null(perim)) return(NULL)

  x17 <- mk_aggr(read_infra(city_tag, "170101"), perim)
  x24 <- mk_aggr(read_infra(city_tag, "240101"), perim)

  m17 <- mk_map(perim, x17, "2016")
  m24 <- mk_map(perim, x24, "2023")
  tmap::tmap_arrange(m17, m24, nrow = 1)
}

# --- display all city panels in the notebook ---
tmap::tmap_mode("plot")
panels <- lapply(city_tags, make_city_panel)
invisible(lapply(panels[!sapply(panels, is.null)], print))

```

## osmactive workflow

```{r}
#| label: setup
remotes::install_github("nptscot/osmactive")
library(osmactive)
library(tidyverse)
```

```{r}
#| label: load-data
library(tmap)
library(osmdata)
library(sf)

paris_poly <- getbb(
  "Paris, France",
  format_out = "sf_polygon",
  featuretype = "settlement"   # <- key bit
) |>
  st_as_sf()

plot(st_geometry(paris_poly))

osm <-  get_travel_network("paris_poly")
cycle_net <-  get_cycling_network(osm)
drive_net <-  get_driving_network(osm)
cycle_net_d <-  distance_to_road(cycle_net, drive_net)
cycle_net_c <-  classify_cycle_infrastructure(cycle_net_d, include_mixed_traffic = FALSE)

# tmap_mode("plot") 
# Clip the cycling network to only include features within Paris
cycle_net_c_paris <- st_intersection(cycle_net_c, paris_poly)

# Now plot the clipped data
m <- plot_osm_tmap(cycle_net_c_paris)
m
```
